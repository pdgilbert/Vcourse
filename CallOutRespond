#!/usr/bin/python3
# License GPL 2. Copyright Paul D. Gilbert, 2018
"""
Run on BTs gizmo to find gizmo at registration distribution and load BTconfig.

This progam should be set up to start automatically when the LED control
gizmo's system is booted. It needs a setting to find other modules, e.g.

export PYTHONPATH=/path/to/Vcourse/lib

Other configuration can also be done with this utility, but might typically be
done before registration.

Boat specific configuration for the gizmo ("FLEET" and "BT_ID" ) is written to BTconfig.
RC specific configuration ("RC_PORT" and "RC_IP") is also written to BTconfig.
GPS harware specific configuration  is written to GPSconfig.

See CallOut for other details.
"""

import socket
import time
import json
#import logging

import smp
import LEDs 

#logFormat ='(%(threadName)-9s) %(message)s'
#logging.basicConfig(level=logging.DEBUG, format=logFormat,)
#logging.basicConfig(level=logging.INFO, format=logFormat,)

def reportBTconfig() :
   """response to Registation udp broadcast 'report config' """

   BTconfig.update({"hn": hn})   # config + hostname

   try :
       sockTCP = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #TCP
       sockTCP.connect(REG) #Registration IP, port       
       l = smp.snd(sockTCP,  str(BTconfig))    
       print(str(l))
       print(str(BTconfig))
       sockTCP.close()
   except :
       raise Exception('error in reportBTconfig')

   LEDs.ok('green Roger.')         


def resetBTconfig() :
   """
   This is in response to Registation udp broadcast 'requestBTconfig' which means BT should
   request a new BTconfig from Registation. This is a bit round-about, 
   but otherwise BT needs a TCP listening process.
   """
   BTconfig.update({"hn": hn})  # config + hostname

   try :
       sockTCP = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #TCP
       sockTCP.connect(REG) #Registration IP, port
       print('sending old conf ' + str(BTconfig))
       l  = smp.snd(sockTCP, str(BTconfig))        
       cf = eval(smp.rcv(sockTCP) ) # str to dict
       cf.update({"hn": hn})
       print('new cf ' + str(cf))
       l  = smp.snd(sockTCP, str(cf))   # echo      
       sockTCP.close()
   except :
       raise Exception('error in resetBTconfig')
   
   LEDs.ok('green Roger.')         
   return cf

################################################################################

if __name__ == '__main__':
   
   ######## init ########

   LEDs.off('lights out')
   shutdown = False
   
   REG = ("10.42.0.254", 9006) # Registration IP and port, should not be hard coded
   
   sockUDP = socket.socket(socket.AF_INET,   socket.SOCK_DGRAM) # UDP
   sockUDP.bind(('', 5005))  #UDP_IP, PORT
   
   try:     BTconfig = json.load(open('BTconfig'))  
   except : BTconfig = {}  

   bt = BTconfig['BT_ID']

   hn = socket.gethostname()

   try:     GPSconfig = json.load(open('GPSconfig')) #Typically "127.0.0.1", 2947 is default port.
   except : GPSconfig = {}                           #This is a problem, but it can be set by broadcast.

   ######## run ########

   while not shutdown:
       # time.sleep(5) misses udp?
       data, addr = sockUDP.recvfrom(1024) # buffer size is 1024 bytes
       data = data.decode()    
       
       data = data.split("::")
       called = data.pop(0)
       request = data[0]
       # in some cases there will be more sections in data
       
       if (bt in called or hn in called ) : 
          # Gizmo specific, not 'all'

          if "checkout" in request :
             LEDs.checkout('blue red green checkout sequence.')         
             LEDs.off('lights out')
             print('doing checkout flash sequence')
          
          elif "checkin" in request :
             LEDs.checkin('red flash.')         
             LEDs.off('lights out')
             print('doing checkin flash')
          
          elif "report config" in request : 
             print('doing reportBTconfig')
             print(str(BTconfig))
             reportBTconfig()
             LEDs.ok('green Roger.')
                
          elif "requestBTconfig" in request :
             #This is a complete reset of the BTconfig.
             cf = resetBTconfig()
             BTconfig.update(cf)
             bt = BTconfig['BT_ID']
             #logging.debug(BTconfig)
             with open('BTconfig', 'w') as f: json.dump(BTconfig, f)
             LEDs.ok('green Roger.')
             #  NEED TO SIGNAL BT TO RESTART/RE-READ CONFIG        
      
       if bt in called or hn in called or 'all' in called :
          
          if "flash" in request :
             LEDs.ok('green Roger.')         
          
          elif "setRC" in request :
             fl =  data[1]          # from UDP broadcast, not TCP connection
             if fl == BTconfig['FLEET'] :
                BTconfig.update(eval(data[2]))
                #logging.debug(BTconfig)
                with open('BTconfig', 'w') as f: json.dump(BTconfig, f)
                LEDs.ok('green Roger.')         
                #  NEED TO SIGNAL BT TO RESTART/RE-READ CONFIG        
          
          elif "setREG" in request :
             #print(str(data[1]))
             REG = eval(data[1])
             LEDs.ok('green Roger.')         



   # never get here unless shutdown mechanism is activated
   sockUDP.close()

   LEDs.cleanup('clean up for shutdown')
