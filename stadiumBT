#!/usr/bin/python3

# License GPL 2. Copyright Paul D. Gilbert, 2017

# need  export PYTHONPATH=/path/to/Vcourse/lib
import threading
import signal
import sys
import time
import logging
import json
import gpsd
import os

import LEDs 
from gpsPos import gpsPos
from gpsPos import getGPS
from distribution import distributionCheck


# Read config variable RC_IP, RC_PORT, BT_ID  from file BTconfig
# in the working directory. 
#    IF THE FILE IS NOT AVAILABLE THE PROGRAM WILL FAIL.
#The file is json and can be generated in python by 
# import json
#  (edit next line example as required)
# config = {'BT_ID' : 'boat 1', 'RC_IP' : '192.168.1.1', 'RC_PORT' : 9001, "GPS_HOST": "127.0.0.1",  "GPS_PORT": 2947}
# json.dump(config, open('BTconfig', 'w'))
# The file can also be editted by hand with care to preserve the dict structure.

# read config
config = json.load(open('BTconfig'))   
BT_ID   = config['BT_ID']
RC_IP   = config['RC_IP']
RC_PORT = int(config['RC_PORT'])
GPS_HOST = config['GPS_HOST']      # typically "127.0.0.1"
GPS_PORT = int(config['GPS_PORT']) # 2947 is default


# start gpsd (-n don't wait for device,  #-S 2947 is default port  FIX?
#sudo gpsd -n -S 2948 /dev/ttyACM0 


#in decreasing order CRITICAL, ERROR, WARNING. INFO, DEBUG
# level logs everything higher. NOTSET looks to parent levels

# filemode='w' will start a new log file each run. Otherwise appending is done.
logging.basicConfig(filename='stadiumBT.log', level=logging.INFO, 
   format='(%(threadName)-9s) %(message)s',)

def zoneSignal(update, shutdown):

    logging.info('zoneSignal starting')

    def status(p, st, now, x=''):
       # return new status and change LEDs if needed
       #LED status  (PWM flickers too fast if constantly reset, so set only on change)
       if now != st :
          if   now == 'off'           : LEDs.off(x)
          elif now == 'bound'         : LEDs.bound(x)
          elif now == 'warn'          : LEDs.warn(x)
          elif now == 'center'        : LEDs.center(x)
          elif now == 'update'        : LEDs.update(x)
          elif now == 'systemProblem' : LEDs.systemProblem(x)
          else :
             logging.warning("LED now status (" + str(now) + ") incorrect.")
             raise ValueError("LED now status (" + str(now) + ") incorrect.")

       # and, BTW, record track
       #p.time comes from the gps. If fractional seconds are available I think
       #  they will be printed, but for now all seem to be .000.
       #  This may be something that can be set on the gps ?
       t.write(str(p.lat) + ' ' + str(p.lon) + ' @ ' + p.time +' LED status ' + now + '\n' )
       return now

    st = 'off'  

    # this try allows recovery after restart, using an already saved file. 
    try :
       with open("BTraceObj.json","r") as f:  raceObj = json.load(f)
       globals().update(raceObj)
       courseLoaded = True
       logging.info("Existing BT course loaded.")
    except:
       courseLoaded = False

    def a(p):
      if dom : a = p.lat - b * p.lon 
      else   : a = p.lon - b * p.lat
      return a

    p = gpsPos(None, None)
    t = open("track.txt","w") 

    
    try:
       gpsd.connect(host=GPS_HOST, port=GPS_PORT) 
    except:
       logging.critical('stadiumBT cannot connect to GPS at ' + GPS_HOST + ':' + str(GPS_PORT))
       logging.critical('stadiumBT will not work without GPS.')
       # this kills thread raise Exception('stadiumBT will not work without GPS.')
       # sys.exit() need to shut down main, but then what?

    try:
       z = a(getGPS()) # try now so fail can provide a message
    except:
       logging.warning("stadiumBT cannot get GPS position. Is gpsd working?")
       logging.warning("Waiting 20 seconds. Check that GPS is connected if there are more errors!!!\n")
       # this kills thread  raise Exception('stadiumBT will not work without GPS.')
       # dont sys.exit(), it may just not be ready
       time.sleep(20)

    while True:
        if shutdown.wait(0.01): # blocking for wait time.
           logging.info('shutting down zoneSignal thread!')
           LEDs.cleanup()
           t.close()
           return() 
        if update.wait(0.01):   # blocking for wait time!
           # read new file here
           logging.info('updating to new raceObj')
           with open("BTraceObj.json","r") as f:  raceObj = json.load(f)

           globals().update(raceObj)
           st = status(p, st, 'update')

           logging.info('  new cid: %s',  cid )
           logging.debug('new course axis:  %f',  axis)
           logging.debug('new course S %f,%f: ', S[0], S[1])

           courseLoaded = True
           t.write('new course loaded: ' + cid + '\n' )
           update.clear()
           logging.debug('update is clear:')
        
        if courseLoaded :
            # run main signal setting loop here
            logging.debug('checking zone status.')
            try:
                p = getGPS() 
                aa = a(p) # this is a in y = a + b * x
                ps= '  @ ' +  str(p.lat) + '  ' + str(p.lon)  # only for debugging
                
                #logging.debug('aa %f', aa)
                # LtoR, # True if bounds increase left to right
                 
                if LtoR :
                   if   boundL  >  aa            : st = status(p, st, 'bound',  'LtoR boundL' + ps) 
                   elif  warnL  >  aa            : st = status(p, st, 'warn',   'LtoR warnL'  + ps)
                   elif centerL <= aa <= centerR : st = status(p, st, 'center', 'LtoR center' + ps)
                   elif            aa >   boundR : st = status(p, st, 'bound',  'LtoR boundR' + ps)
                   elif            aa >    warnR : st = status(p, st, 'warn',   'LtoR warnR'  + ps)
                   else                          : st = status(p, st, 'off',     'LtoR '      + ps)
                else :
                   if    boundR >  aa            : st = status(p, st, 'bound',  'boundR'      + ps)
                   elif   warnR >  aa            : st = status(p, st, 'warn',   'warnR'       + ps)
                   elif centerR <= aa <= centerL : st = status(p, st, 'center', 'center'      + ps)
                   elif            aa >   boundL : st = status(p, st, 'bound',  'boundL'      + ps)
                   elif            aa >    warnL : st = status(p, st, 'warn',   'warnL'       + ps)
                   else                          : st = status(p, st, 'off')

            except:
               st = status(p, st, 'systemProblem', '. No GPS fix.')

            time.sleep(0.1) #0.5 worked but is a bit slow

    raise Exception('zoneSignal should not be here.')

if __name__ == '__main__':
   logging.info('main thread starting. ' +time.strftime('%Y-%m-%d %H:%M:%S %Z'))
   update   = threading.Event()
   shutdown = threading.Event()

   logging.info('main thread starting distributionCheck thread.')
   threading.Thread(name='distributionCheck', 
   		   target=distributionCheck, 
   		   args=(update, shutdown,  10, RC_IP, RC_PORT, BT_ID)).start()

   logging.info('main thread starting zoneSignal thread.')
   threading.Thread(name='zoneSignal', 
   		   target=zoneSignal, 
   		   args=(update, shutdown)).start()
   
   # consider myThread.daemon = True so threads shut down

   def shutdownHandler(signum, frame):
       logging.info('main thread setting shutdown signal.')
       shutdown.set()  # to exit threads
       time.sleep(5)
       logging.info('main thread exit.' +time.strftime('%Y-%m-%d %H:%M:%S %Z')+ '\n')
       sys.exit()

   # ^C works if process is not deamonized with &
   signal.signal(signal.SIGINT,  shutdownHandler) # ^C, kill -2
   signal.signal(signal.SIGTERM, shutdownHandler) # kill -15 (default)

   while True: time.sleep(600) # Ctrl+c or kill to exit

