#!/usr/bin/python3

# License GPL 2. Copyright Paul D. Gilbert, 2017

# need     export PYTHONPATH=/path/to/Vcourse/lib
import threading
import signal
import sys
import time
import logging
import json
import gpsd
import os

import LEDs 
from gpsPos import gpsPos
from gpsPos import getGPS
from distribution import distributionCheck

#in decreasing order CRITICAL, ERROR, WARNING. INFO, DEBUG
# level logs everything higher. NOTSET looks to parent levels

logFormat ='(%(threadName)-9s) %(message)s'
#logging.basicConfig(level=logging.DEBUG, format=logFormat,)
logging.basicConfig(level=logging.INFO, format=logFormat,)

# filemode='w' will start a new log file each run. Otherwise appending is done.
#logging.basicConfig(filename='stadiumBT.log',
#                    level=logging.DEBUG, format=logFormat,)


# Read config variable RC_IP, RC_PORT, BT_ID  from file BTconfig
# in the working directory. 
#    IF THE FILE IS NOT AVAILABLE THE PROGRAM WILL FAIL.
#The file is json and can be generated in python by 
# import json
#  (edit next line example as required)
# config = {'BT_ID' : 'boat 1', 'RC_IP' : '192.168.1.1', 'RC_PORT' : 9001, "GPS_HOST": "127.0.0.1",  "GPS_PORT": 2947}
# json.dump(config, open('BTconfig', 'w'))
# The file can also be editted by hand with care to preserve the dict structure.

# read config
config = json.load(open('BTconfig'))   
BT_ID   = config['BT_ID']
RC_IP   = config['RC_IP']
RC_PORT = int(config['RC_PORT'])
GPS_HOST = config['GPS_HOST']      # typically "127.0.0.1"
GPS_PORT = int(config['GPS_PORT']) # 2947 is default

# cid needs to be global as it is used and changed by both zoneSignal and 
# distributionCheck threads. The usual update would be in zoneSignal, after
# and update has been signalled by distributionCheck. But distributionCheck
# will set it when first intiallizing 

cid = None

# start gpsd (-n don't wait for device,  #-S 2947 is default port  FIX?
#sudo gpsd -n -S 2948 /dev/ttyACM0 


class zoneSignal(threading.Thread):
   # this thread class is used by BT
  
   def __init__(self, update, shutdown):
      threading.Thread.__init__(self)

      global cid
      self.name='zoneSignal'
      self.update = update
      self.shutdown = shutdown

      # this try allows recovery after restart, using an already saved file. 
      try :
         with open("activeBTzoneObj.json","r") as f:  self.zoneObj = json.load(f)
         #globals().update(self.zoneObj)
         logging.info("Existing BT course loaded.")
      except:
         self.zoneObj = None
         cid = None

      self.t = open("track.txt","w") 

      try:
         gpsd.connect(host=GPS_HOST, port=GPS_PORT) 
      except:
         logging.critical('stadiumBT cannot connect to GPS at ' + GPS_HOST + ':' + str(GPS_PORT))
         logging.critical('stadiumBT will not work without GPS.')
         # this kills thread raise Exception('stadiumBT will not work without GPS.')
         # sys.exit() need to shut down main, but then what?

      try:
         z = getGPS() # try now so fail can provide a message
      except:
         logging.warning("stadiumBT cannot get GPS position. Is gpsd working?")
         logging.warning("Waiting 20 seconds. Check that GPS is connected if there are more errors!!!\n")
         # this kills thread  raise Exception('stadiumBT will not work without GPS.')
         # do not sys.exit(), gps may just not be ready
         time.sleep(20)

      logging.info('zoneSignal initialized. cid = ' + str(cid))

   def run(self):
      logging.info('zoneSignal started.')
      global cid
      locals().update(self.zoneObj)

      def record(p, now):
         # record track
         #p.time comes from the gps. If fractional seconds are available I think
         #  they will be printed, but for now all seem to be .000.
         #  This may be something that can be set on the gps ?
         self.t.write(str(p.lat) + ' ' + str(p.lon) + ' @ ' + p.time +' LED status ' + now + '\n' )
 
      def a(p):
         if dom : a = p.lat - b * p.lon 
         else        : a = p.lon - b * p.lat
         return a

      def setNow(p, now, x=""):
         print('now ' + now)
         LEDs.setLEDs(now, x)
         record(p, now)

      def unwind(zO):
         # compare makezoneObj()  in stadiumRC
         cid        = zO['cid']
         courseDesc = zO['courseDesc']
         courseType = zO['courseType']
         distributionTime = zO['distributionTime']
         length     = zO['length']
         axis       = zO['axis']
         S          = zO['S']
         M          = zO['M']
         dom        = zO['dom']
         LtoR       = zO['LtoR']
         b          = zO['b']
         boundL     = zO['boundL']
         boundR     = zO['boundR']
         warnL      = zO['warnL']
         warnR      = zO['warnR']
         centerL    = zO['centerL']
         centerR    = zO['centerR']
         
         return((cid, courseDesc, courseType, distributionTime, length, axis,
           S, M, dom, LtoR, b, boundL, boundR, warnL, warnR, centerL, centerR ))

      p = gpsPos(None, None)

      while not self.shutdown.is_set():   

          if self.update.is_set():  
             logging.info('updating to new zoneObj')
             with open("activeBTzoneObj.json","r") as f:  self.zoneObj = json.load(f)

             # There is an important difference between python2 and python3 
             #  for exec(). In theory some variation on the next should work, but see
             #https://stackoverflow.com/questions/1463306/how-does-exec-work-with-locals
             #for k, v in self.zoneObj.items():  exec (k + '=v') # unpack
             # so
             (cid, courseDesc, courseType, distributionTime, length, axis,
                S, M, dom, LtoR, b, boundL, boundR, warnL, warnR, 
                centerL, centerR ) = unwind(self.zoneObj)

             if cid is None :
                raise Exception('something is wrong. cid is none after update with zoneObj).')

             setNow(p,  'update')

             logging.info('  new cid: %s',  cid)
             #logging.debug('new course axis:  %f',  axis)
             #logging.debug('new course S %f,%f: ', S[0], S[1])

             self.t.write('new course loaded: ' + cid + '\n' )
             self.update.clear()
             logging.debug('update is clear:')
          
          if cid is not None :
              # run main signal setting loop here
              #logging.debug('checking zone status.')
              try:
                  p = getGPS() 
              except:
                 setNow(p,'systemProblem', '. No GPS fix.')

              try:
                 aa = a(p) # this is a in y = a + b * x
                 ps= '  @ ' +  str(p.lat) + '  ' + str(p.lon)  # only for debugging
                 
                 print('aa %f', aa)
                 print('LtoR ', str(LtoR))
                 print('boundL ', str(boundL))
                 # LtoR, # True if bounds increase left to right
                  
                 if LtoR :
                    if   boundL  >  aa            : setNow(p, 'bound',  'LtoR boundL' + ps) 
                    elif  warnL  >  aa            : setNow(p, 'warn',   'LtoR warnL'  + ps)
                    elif centerL <= aa <= centerR : setNow(p, 'center', 'LtoR center' + ps)
                    elif            aa >   boundR : setNow(p, 'bound',  'LtoR boundR' + ps)
                    elif            aa >    warnR : setNow(p, 'warn',   'LtoR warnR'  + ps)
                    else                          : setNow(p, 'off',     'LtoR '      + ps)
                 else :
                    if    boundR >  aa            : setNow(p, 'bound',  'boundR'      + ps)
                    elif   warnR >  aa            : setNow(p, 'warn',   'warnR'       + ps)
                    elif centerR <= aa <= centerL : setNow(p, 'center', 'center'      + ps)
                    elif            aa >   boundL : setNow(p, 'bound',  'boundL'      + ps)
                    elif            aa >    warnL : setNow(p, 'warn',   'warnL'       + ps)
                    else                          : setNow(p, 'off')

              except:
                 setNow(p,'systemProblem', 'in zone calculation')

              time.sleep(2) #0.1) #0.5 worked but is a bit slow IMPACTS TRACK FILE SIZE

      LEDs.cleanup()
      self.t.close()
      logging.info('exiting zoneSignal thread.')


if __name__ == '__main__':
   logging.info('main thread starting. ' +time.strftime('%Y-%m-%d %H:%M:%S %Z'))
   update   = threading.Event()
   shutdown = threading.Event()

   logging.debug('main thread starting distributionCheck thread.')
   distributionCheck(RC_IP, RC_PORT, BT_ID, update, shutdown).start()

   logging.debug('main thread starting zoneSignal thread.')
   zoneSignal(update, shutdown).start()

   logging.debug(threading.enumerate())
 
   def shutdownHandler(signum, frame):
       logging.info('main thread setting shutdown signal.')
       shutdown.set()  # to exit threads
       time.sleep(5)
       logging.info('main thread exit.' +time.strftime('%Y-%m-%d %H:%M:%S %Z')+ '\n')
       logging.debug('threads still running:')
       logging.debug(threading.enumerate())
       sys.exit()

   # ^C works if process is not deamonized with &
   signal.signal(signal.SIGINT,  shutdownHandler) # ^C, kill -2
   signal.signal(signal.SIGTERM, shutdownHandler) # kill -15 (default)

   while True: time.sleep(600) # Ctrl+c or kill to exit

