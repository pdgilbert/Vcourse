#!/usr/bin/python3

# License GPL 2. Copyright Paul D. Gilbert, 2017

import threading
import signal
import sys
import time
#import logging
import json
import gpsd
import os

#os.uname()[4] == 'armv6l' is True on Pi Zero W,  but will not distinguish other boards. Maybe better ideas
# at https://github.com/adafruit/Adafruit_Python_GPIO/blob/master/Adafruit_GPIO/Platform.py

if os.uname()[4] == 'armv6l' :
   import LED_piZeroW   as LEDs 
else :
   import LED_simulate  as LEDs 

from gpsPos import gpsPos

from distribution import distributionCheck


# Read config variable RC_IP, RC_PORT, BT_ID  from file BTconfig
# in the working directory. 
#    IF THE FILE IS NOT AVAILABLE THE PROGRAM WILL FAIL.
#The file is json and can be generated in python by 
# import json
#  (edit next line example as required)
# config = {'RC_IP' : '192.168.1.1', 'RC_PORT' : 9001, 'BT_ID' : 'boat 1'}
# json.dump(config, open('BTconfig', 'w'))
# The file can also be editted by hand with care to preserve the dict structure.

# read config
config = json.load(open('BTconfig'))   
RC_IP   = config['RC_IP']
RC_PORT = int(config['RC_PORT'])
BT_ID   = config['BT_ID']


# start gpsd (-n don't wait for device,  #-S 2947 is default port  FIX?
#sudo gpsd -n -S 2948 /dev/ttyACM0 

gpsd_host="127.0.0.1"
gpsd_port=2948      #2947 is default


#DEBUG, NOTSET, ERROR, WARNING
#logging.basicConfig(level=logging.DEBUG, format='(%(threadName)-9s) %(message)s',)


def zoneSignal(update, shutdown):

    # this try allows recovery after restart, using an already saved file. 
    try :
       with open("BTraceObj.json","r") as f:  raceObj = json.load(f)
       globals().update(raceObj)
       courseLoaded = True
    except:
       courseLoaded = False

    def a(p):
      if dom : a = p.lat - b * p.lng 
      else   : a = p.lng - b * p.lat
      return a

    print('zoneSignal starting')
    
    try:
       gpsd.connect(host=gpsd_host, port=gpsd_port) 
   except RuntimeError:
       print("Error stadiumBT cannot connect to GPS deamon. Usual problem?")
       raise Exception('stadiumBT will not work without GPS.')

    while True:
        if shutdown.wait(0.01): # blocking for wait time.
           print('shutting down zoneSignal thread!')
           LEDs.cleanup()
           return() 
        if update.wait(0.01):   # blocking for wait time!
           # read new file here
           #logging.debug('updating raceObj')
           with open("BTraceObj.json","r") as f:  raceObj = json.load(f)

           globals().update(raceObj)
           LEDs.update()
 
           #logging.debug('new cid: %s',  cid )
           #logging.debug('new course axis:  %f',  axis)
           #logging.debug('new course S %f,%f: ', S[0], S[1])

           courseLoaded = True
           update.clear()
           #logging.debug('update is clear:')
        
        if courseLoaded :
            # run main signal setting loop here
            #logging.debug('in zone?')
            aa = a(gpsPos.getGPS()) # this is a in y = a + b * x
            
            #logging.debug('aa %f', aa)
            # LtoR, # True if bounds increase left to right
             
            if LtoR :
               if   boundL  >  aa            : LEDs.bound('LtoR boundL')
               elif  warnL  >  aa            : LEDs.warn('LtoR warnL')
               elif centerL <= aa <= centerR : LEDs.center('LtoR center')
               elif            aa >   boundR : LEDs.bound('LtoR boundR')
               elif            aa >    warnR : LEDs.warn('LtoR warnR')
               else                          : LEDs.off('LtoR ')
            else :
               if    boundR >  aa            : LEDs.bound('boundR')
               elif   warnR >  aa            : LEDs.warn('warnR')
               elif centerR <= aa <= centerL : LEDs.center('center')
               elif            aa >   boundL : LEDs.bound('boundL')
               elif            aa >    warnL : LEDs.warn('warnL')
               else                          : LEDs.off()

            time.sleep(3)  # REALLY SHORTER  FIX

    raise Exception('zoneSignal should not be here.')

if __name__ == '__main__':

   update   = threading.Event()
   shutdown = threading.Event()

   threading.Thread(name='distributionCheck', 
   		   target=distributionCheck, 
   		   args=(update, shutdown,  10, RC_IP, RC_PORT, BT_ID)).start()

   threading.Thread(name='zoneSignal', 
   		   target=zoneSignal, 
   		   args=(update, shutdown)).start()
   

   def shutdownHandler(signum, frame):
       shutdown.set()  # to exit threads
       print('main thread exit.')
       sys.exit()

   signal.signal(signal.SIGINT, shutdownHandler)

   while True: time.sleep(600) # Ctrl+c or kill to exit

