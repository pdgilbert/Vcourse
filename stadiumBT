#!/usr/bin/python3

# License GPL 2. Copyright Paul D. Gilbert, 2017

import socket

# read from config file   FIX
#RC_IP = 'xxx.xxx.xxx.xxx' 
RC_PORT = 9001

BT_ID = socket.gethostname()

import threading
import time
import logging
import json

from gpsPos import gpsPos

# start gpsd (-n don't wait for device,  #-S 2947 is default port  FIX?
#sudo gpsd -n -S 2948 /dev/ttyACM0 

gpsd_host="127.0.0.1"
gpsd_port=2948      #2947 is default

# initialized as these may be used even before a proper raceObj is generated
courseID =None 


#DEBUG, NOTSET, ERROR, WARNING
logging.basicConfig(level=logging.DEBUG,
                    format='(%(threadName)-9s) %(message)s',)


def distributionCheck(update, shutdown, interval):
    # BT sends RC the cid (cousreID and distritution time) BT has.
    # RC replies with  'ok' indicating there is no update,
    #     or 'none' indicating no course set yet, or with updated raceObj.
    # BT confirms receipt of update with bt# or hostname?  

    import smp

    logging.debug('distributionCheck starting')

    while True:
        if shutdown.wait(interval):    # effectively sleep too
           logging.debug('shutting down distributionCheck thread.')
           return() 
        
        # check RC for update
        #logging.debug('check RC for update.')
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((RC_IP, RC_PORT))
        
        if (courseID == None ) :
           cid = 'none'
        else :
           cid = str(courseID) + ' ' +  distributionTime
        
        l = smp.snd(s, cid)
        #logging.debug("BT cid " + str(cid))
        
        r = smp.rcv(s) 
        #logging.debug('r ' + str(r))

        if not (r in ('ok', 'none')) :
            logging.debug('got new raceObj. Writing to file BTraceObj.json')
            # Next could be a message to zoneSignal thread, but having a
            # file means the gadget can recover after reboot without
            # a connection to RC, so write string r to a file
            with open("BTraceObj.json","w") as f: f.write(r) 
            update.set()
            logging.debug('flash all lights.')

            l = smp.snd(s, BT_ID)
            logging.debug("confirmed  receipt BT " + str(BT_ID))

        s.close()
        #logging.debug('connection closed')

    logging.debug('distributionCheck should not be here.')

def zoneSignal(update, shutdown):

    import gpsd

    if True : import LED_simulate  as LEDs # replace with hardware file  FIX

    def a(p):
      if dom : a = p.lat - b * p.lng 
      else   : a = p.lng - b * p.lat
      return a

    logging.debug('zoneSignal starting')

    courseLoaded = False
    
    gpsd.connect(host=gpsd_host, port=gpsd_port) 

    while True:
        if shutdown.wait(0.01): # blocking for wait time.
           logging.debug('shutting down zoneSignal thread!')
           return() 
        if update.wait(0.01):   # blocking for wait time!
           # read new file here
           logging.debug('updating raceObj')
           with open("BTraceObj.json","r") as f:  raceObj = json.load(f)

           globals().update(raceObj)
           
           #logging.debug('new courseID: %s',  courseID )
           #logging.debug('new course axis:  %f',  axis)
           #logging.debug('new course S %f,%f: ', S[0], S[1])

           courseLoaded = True
           update.clear()
           #logging.debug('update is clear:')
        
        if courseLoaded :
            # run main signal setting loop here
            #logging.debug('in zone?')
            aa = a(gpsPos.getGPS()) # this is a in y = a + b * x
            
            #logging.debug('aa %f', aa)
            # LtoR, # True if bounds increase left to right
             
            if LtoR :
               if   boundL  >  aa            : LEDs.bound('LtoR boundL')
               elif  warnL  >  aa            : LEDs.warn('LtoR warnL')
               elif centerL <= aa <= centerR : LEDs.center('LtoR center')
               elif            aa >   boundR : LEDs.bound('LtoR boundR')
               elif            aa >    warnR : LEDs.warn('LtoR warnR')
               else                          : LEDs.off('LtoR ')
            else :
               if    boundR >  aa            : LEDs.bound('boundR')
               elif   warnR >  aa            : LEDs.warn('warnR')
               elif centerR <= aa <= centerL : LEDs.center('center')
               elif            aa >   boundL : LEDs.bound('boundL')
               elif            aa >    warnL : LEDs.warn('warnL')
               else                          : LEDs.off()

            time.sleep(20)  # REALLY SHORTER  FIX

    logging.debug('zoneSignal should not be here.')

if __name__ == '__main__':
   update   = threading.Event()
   shutdown = threading.Event()

   threading.Thread(name='distributionCheck', 
   		   target=distributionCheck, 
   		   args=(update, shutdown,  10)).start()

   threading.Thread(name='zoneSignal', 
   		   target=zoneSignal, 
   		   args=(update, shutdown)).start()
   
   import signal

   def shutdownHandler(signum, frame):
       import sys
       shutdown.set()  # to exit threads
       print('main thread exit.')
       sys.exit()

   signal.signal(signal.SIGINT, shutdownHandler)

   while True: time.sleep(600) # Ctrl+c or kill to exit

