#!/usr/bin/python3

# License GPL 2. Copyright Paul D. Gilbert, 2017

# need     export PYTHONPATH=/path/to/Vcourse/lib

import logging

#in decreasing order CRITICAL, ERROR, WARNING. INFO, DEBUG
# level logs everything higher. NOTSET looks to parent levels

# basicConfigcan only be set once in a python session. Additional calls ignored.
#logging.basicConfig(level=logging.DEBUG, format='(%(threadName)-9s) %(message)s')
logging.basicConfig(level=logging.INFO, format='(%(threadName)-9s) %(message)s')
logging.info('message level info.')
logging.debug('message level debug.')

import threading
import signal
import sys
import time
import json
import gpsd
import os

import LEDs 
import gpsPos
from distribution import distributionCheck


# filemode='w' will start a new log file each run. Otherwise appending is done.
#logging.basicConfig(filename='stadiumBT.log',
#                    level=logging.DEBUG, format=logFormat,)


# Read config variable RC_IP, RC_PORT, BT_ID  from file BTconfig
# in the working directory. 
#    IF THE FILE IS NOT AVAILABLE THE PROGRAM WILL FAIL.
#The file is json and can be generated in python by 
# import json
#  (edit next line example as required)
# config = {'BT_ID' : 'boat 1', 'RC_IP' : '192.168.1.1', 'RC_PORT' : 9001, "GPS_HOST": "127.0.0.1",  "GPS_PORT": 2947}
# json.dump(config, open('BTconfig', 'w'))
# The file can also be editted by hand with care to preserve the dict structure.

# read config
config = json.load(open('BTconfig'))   
BT_ID   = config['BT_ID']
RC_IP   = config['RC_IP']
RC_PORT = int(config['RC_PORT'])
GPS_HOST = config['GPS_HOST']      # typically "127.0.0.1"
GPS_PORT = int(config['GPS_PORT']) # 2947 is default

# cid needs to be global as it is used and changed by both zoneSignal and 
# distributionCheck threads. The usual update would be in zoneSignal, after
# an update has been signalled by distributionCheck. But distributionCheck
# will set it when first intiallizing 

cid = None

# start gpsd (-n don't wait for device,  #-S 2947 is default port  FIX?
#sudo gpsd -n -S 2948 /dev/ttyACM0 


class zoneSignal(threading.Thread):
   # this thread class is used by BT
  
   def __init__(self, update, shutdown):
      threading.Thread.__init__(self)

      global cid
      self.name='zoneSignal'
      self.update = update
      self.shutdown = shutdown

      # this try allows recovery after restart, using an already saved file. 
      try :
         with open("activeBTzoneObj.json","r") as f:  self.zoneObj = json.load(f)
         #globals().update(self.zoneObj)
         logging.info("Existing BT course loaded.")
         logging.info('   cid = ' + str(self.zoneObj["cid"]))
      except:
         self.zoneObj = None

      self.t = open("track.txt","w") 

      try:
         gpsd.connect(host=GPS_HOST, port=GPS_PORT) 
      except:
         logging.info('stadiumBT cannot connect to GPS at ' + GPS_HOST + ':' + str(GPS_PORT))
         # do not kill the thread, it may be temporary

      z = getGPS() # try now so fail can provide a message

      if z is None :
         # do not kill the thread, it may be temporary
         logging.warning("stadiumBT cannot get GPS position at initialization.")
         LEDs.setLEDs('noGPSfix', ' at initialization.')
      else :
         LEDs.setLEDs('off', ' at initialization.')

      logging.info('zoneSignal initialized.')

   def run(self):
      logging.info('zoneSignal started.')
      global cid
 
      def a(p):
         if dom : a = p.lat - b * p.lon 
         else        : a = p.lon - b * p.lat
         return a

      def unwind(zO):
         # compare makezoneObj()  in stadiumRC
         cid        = zO['cid']
         courseDesc = zO['courseDesc']
         courseType = zO['courseType']
         distributionTime = zO['distributionTime']
         length     = zO['length']
         axis       = zO['axis']
         S          = zO['S']
         M          = zO['M']
         dom        = zO['dom']
         LtoR       = zO['LtoR']
         b          = zO['b']
         boundL     = zO['boundL']
         boundR     = zO['boundR']
         warnL      = zO['warnL']
         warnR      = zO['warnR']
         centerL    = zO['centerL']
         centerR    = zO['centerR']
         
         return((cid, courseDesc, courseType, distributionTime, length, axis,
           S, M, dom, LtoR, b, boundL, boundR, warnL, warnR, centerL, centerR ))

      if self.zoneObj is not None:
         (cid, courseDesc, courseType, distributionTime, length, axis,
                S, M, dom, LtoR, b, boundL, boundR, warnL, warnR, 
                centerL, centerR ) = unwind(self.zoneObj)

      sk =0

      while not self.shutdown.is_set():   

          if self.update.is_set():  
             logging.info('updating to new zoneObj')
             with open("activeBTzoneObj.json","r") as f:  self.zoneObj = json.load(f)

             # There is an important difference between python2 and python3 
             #  for exec(). In theory some variation on the next should work, but see
             #https://stackoverflow.com/questions/1463306/how-does-exec-work-with-locals
             #for k, v in self.zoneObj.items():  exec (k + '=v') # unpack
             # so
             (cid, courseDesc, courseType, distributionTime, length, axis,
                S, M, dom, LtoR, b, boundL, boundR, warnL, warnR, 
                centerL, centerR ) = unwind(self.zoneObj)

             if cid is None :
                raise Exception('something is wrong. cid is None after update with zoneObj).')

             LEDs.setLEDs('update')

             logging.info('  new cid: %s',  cid)
             #logging.debug('new course axis:  %f',  axis)
             #logging.debug('new course S %f,%f: ', S[0], S[1])

             self.t.write('new course loaded: ' + cid + '\n' )
             self.update.clear()
             logging.debug('update is clear:')
          
          if cid is not None :
              # run main signal setting loop here
              #logging.debug('checking zone status.')
              
              p = gpsPos.getGPS()
              
              if p is None:
                 LEDs.setLEDs('noGPSfix', x='. No GPS fix.')
                 tr = 'No GPS fix. LED status  noGPSfix'
                 logging.info('p is None.')
              else:
                 logging.info('p is ' + str(p.lat))
                 aa = a(p) # this is a in y = a + b * x
                 ps= '  @ ' +  str(p.lat) + '  ' + str(p.lon)  # only for debugging
                 
                 # LtoR, # True if bounds increase left to right
                  
                 if LtoR :
                    if   boundL  >  aa            : now = ('bound',  'LtoR boundL') 
                    elif  warnL  >  aa            : now = ('warn',   'LtoR warnL' )
                    elif centerL <= aa <= centerR : now = ('center', 'LtoR center')
                    elif            aa >   boundR : now = ('bound',  'LtoR boundR')
                    elif            aa >    warnR : now = ('warn',   'LtoR warnR' )
                    else                          : now = ('off',    'LtoR'       )
                 else :
                    if    boundR >  aa            : now = ('bound',  'boundR')
                    elif   warnR >  aa            : now = ('warn',   'warnR' )
                    elif centerR <= aa <= centerL : now = ('center', 'center')
                    elif            aa >   boundL : now = ('bound',  'boundL')
                    elif            aa >    warnL : now = ('warn',   'warnL' )
                    else                          : now = ('off',    ''      )

                 LEDs.setLEDs(now[0], now[1]+ ps)
                 tr = str(p.lat) + ' ' + str(p.lon) + ' @ ' + p.time +' LED status ' + now[0]

              # record track. p.time comes from the gps. 
              # If fractional seconds are available I think they will be printed,
              #   but for now all seem to be .000.
              #   This may be something that can be set on the gps ?
              # Record only every 5 second so modulo in next depends on sleep 
              #   time. Record frequency impacts track file size.
              
              if sk is 0 :  self.t.write(tr + '\n' )
              sk = (sk + 1) % 50  
   
              time.sleep(0.1) #0.5 worked but is a bit slow

      LEDs.cleanup()
      self.t.close()
      logging.info('exiting zoneSignal thread.')

if __name__ == '__main__':

   logging.info('main thread starting. ' +time.strftime('%Y-%m-%d %H:%M:%S %Z'))
   update   = threading.Event()
   shutdown = threading.Event()

   distributionCheck(RC_IP, RC_PORT, BT_ID, update, shutdown).start()

   zoneSignal(update, shutdown).start()

   logging.debug(threading.enumerate())
 
   def shutdownHandler(signum, frame):
       logging.info('main thread setting shutdown signal.')
       shutdown.set()  # to exit threads
       time.sleep(5)
       logging.info('main thread exit.' +time.strftime('%Y-%m-%d %H:%M:%S %Z')+ '\n')
       logging.debug('threads still running:')
       logging.debug(threading.enumerate())
       sys.exit()

   # ^C works if process is not deamonized with &
   signal.signal(signal.SIGINT,  shutdownHandler) # ^C, kill -2
   signal.signal(signal.SIGTERM, shutdownHandler) # kill -15 (default)

   while True: time.sleep(600) # Ctrl+c or kill to exit

