#!/usr/bin/python3

# License GPL 2. Copyright Paul D. Gilbert, 2017

# need  export PYTHONPATH=/path/to/Vcourse/lib

import socket
import threading
import signal
import logging
import json
import time
import tkinter
from tkinter import filedialog
import gpsd
import math
import sys

from gpsPos import gpsPos
from gpsPos import getGPS

import distribution

logFormat ='(%(threadName)-9s) %(message)s'
#logging.basicConfig(level=logging.DEBUG, format=logFormat,)
logging.basicConfig(level=logging.INFO, format=logFormat,)


# Read config variable RC_IP, RC_PORT  from file RCconfig
# in the working directory. 
#    IF THE FILE IS NOT AVAILABLE THE PROGRAM WILL FAIL.
#The file is json and can be generated in python by 
# import json
#  (edit next line example as required)
# config = {'RC_IP' : '192.168.1.1', 'RC_PORT' : 9001, "GPS_HOST": "127.0.0.1",  "GPS_PORT": 2947}
# json.dump(config, open('RCconfig', 'w'))
# The file can also be editted by hand with care to preserve the dict structure.

# read config
config = json.load(open('RCconfig'))   
RC_IP   = config['RC_IP']
RC_PORT = int(config['RC_PORT'])
GPS_HOST = config['GPS_HOST']      # typically "127.0.0.1"
GPS_PORT = int(config['GPS_PORT']) # 2947 is default

# position below means a gpsPos object.
# left and right looking up the course, from race committee (RC) to windward mark (M)
# these global variables should have values as displayed on RaceWindow screen

# set initial default race parameters
#  Could save last on exit and reload ?

fl   = 'no fleet'   # fleet
dc   = 'race 1'     # description
ty   = 'stadium'    # course type
cl   = 1.0          # course length (nm)
ax   = 240          # course bearing (degrees)
ll   = 100          # start line length (m)
sw   = 200          # stadium width (m)
RC   = gpsPos(44.210171667,-76.51047667) # RC position (default Pen. shoal)
S    = gpsPos(0,0)  # start line center position
M    = gpsPos(0,0)  # windward mark position 
wn   = 20           # distance (m) from boundary at which warning is indicated
cc   = 20           # width (m) around center axis where center is  indicated 
tt   = 0            # target start time


def readBoatList(w=None):
   global  BoatList

   if w is not None: w.destroy()

   try : 
      with open("BoatList") as f:  BoatList =  f.read().splitlines()
      BoatList = [b.strip() for b in BoatList]
   except :
      BoatList = None   

readBoatList()

def readgpsList(w=None):
   global  gpsList

   if w is not None: w.destroy()

   gpsList = []
   try : 
      with open("gpsList") as f:
         for i in f.readlines():
            l =  i.split()
            gpsList.append( (l[0], l[1], l[2]) )
   except :
      gpsList = None   

readgpsList()


def writeRaceFile(w, filename = None):
   # no calc
   w.destroy()

   readRaceWindow() #sync globals from screen
   if filename is None : 
      #t = tkinter.Toplevel()
      filename =  filedialog.asksaveasfile(mode="w",  defaultextension=".raceParms",
          initialdir = "", title = "enter file name to save",
          filetypes = (("race parameters","*.raceParms"),("all files","*.*")))
   if filename is None: # i.e. cancel clicked in dialog
      return
   filename.close() # use json.dump() below, but above opened the file
   filename = str(filename.name)

   try : 
      Race = { 'fl':fl, 'dc':dc, 'ty':ty, 'cl':cl, 'ax':ax, 'll':ll, 'sw':sw, 
                      'RC.lat':RC.lat, 'RC.lon':RC.lon, 'S.lat':S.lat, 'S.lon':S.lon, 'M.lat':M.lat, 'M.lon':M.lon,
                      'wn':wn, 'cc':cc, 'tt':tt }
      with open(filename, "w") as f:  json.dump(Race, f)
   except :
      raise Exception('error writing race parameters to file ' + str(filename))

def readRaceFile(w, filename = None):
   global  fl, dc, ty, cl, ax, ll, sw, RC, S, M, wn, cc, tt
   w.destroy()

   if filename is None : 
      #t = tkinter.Toplevel()
      #t =  tkinter.Tk()
      filename =  filedialog.askopenfilename(initialdir = "",
        title = "choose file",
        filetypes = (("race parameters","*.raceParms"),("all files","*.*")))

   if filename is "": # i.e. cancel clicked in dialog
      return

   with open(filename) as f:  defaultRace = json.load(f)   

   try : 
      fl   = defaultRace['fl']
      dc   = defaultRace['dc']
      ty   = defaultRace['ty']
      cl   = defaultRace['cl']
      ax   = defaultRace['ax']
      ll   = defaultRace['ll']
      sw   = defaultRace['sw']
      RC   = gpsPos(defaultRace['RC.lat'], defaultRace['RC.lon'])
      S    = gpsPos(defaultRace[ 'S.lat'], defaultRace[ 'S.lon'])
      M    = gpsPos(defaultRace[ 'M.lat'], defaultRace[ 'M.lon'])
      wn   = defaultRace['wn']
      cc   = defaultRace['cc']
      tt   = defaultRace['tt']
   except :
      raise Exception('error defining race parameters from file ' + filename)

   writeRaceWindow() #sync screen from globals

def gpsRead(h, p):
   logging.debug('gpsRead:' + h + ':' + str(p) + '.')
   try : 
      gpsCon = gpsd.connect(host=h, port=int(p))
      pt = getGPS()
      #logging.debug('gpsRead:' + h + ':' + str(p) + '.' + 
      #                     ' pt  ' + str(pt.lat) + str(pt.lon))
   except :
      pt   = None
      #logging.debug('gpsRead:' + h + ':' + str(p) + '.' + ' pt  ' + str(pt))
   return(pt)

def getRCgps():
   # update global RC and write to screen
   global  RC
   RC = gpsRead(GPS_HOST, GPS_PORT)
   if RC == None :
      RC   = gpsPos(90.0, 0.0)  # this is really an error condition
      logging.info('attempted gpsd connection '   + str(GPS_HOST) + ':' +  str(GPS_PORT))
      logging.info('gpsd connection failed. No RC automatic position available.')
   writeRaceWindow()



def makezoneObj():
   # This  syncronizes globals dist, generates zoneObj, calls distribute
   # info to pass to stadiumBT (boat gadget) for calculations.
   # Info for stadiumBT is all in gps positions as that is the best for the
   # boats' calculation of what indicators should go on.
   # The same info is used by plot but is convert to nm in plot.
      
   # base on current screen values so ensure correct values in globals
   readRaceWindow() 

   # y = a + b * x
   # b = (y_1 - y_2) / (x_1 - x_2)
   # a = y_1 - b * x_1
   
   # 0 or 180 axis would give infinite slope is x is longitude, 
   # so depending on the axis treat domain as longitude (dom=True)
   # or treat domain as latitude (dom=False)
   if        45 <= ax <= 135 : dom = True
   elif     225 <= ax <= 315 : dom = True
   else                      : dom = False

   #  NOT !!
   # Next are globals not on screen but used for zoneObj calculation, and plot.
   # These are positions at intersection of the start line extension and one of
   # the lines parallel to axis used for switching indicators (LEDs) on boats.

   w = sw / 1852  # stadium width in nm
   perp = (ax - 90 ) % 360 # bearing RC to pin, RC on starboard end of line.
   #                         This is bearing used for extensions of starting line

   # Two positions on axis (S and M) give slope b.
   if dom : b = (M.lat - S.lat) / (M.lon - S.lon)
   else   : b = (M.lon - S.lon) / (M.lat - S.lat)

   if dom :
      if   45 <= ax <= 135 : LtoR = False
      else                 : LtoR = True  # 225 <= ax <= 315 
   else :
      if   135 <= ax <= 225 : LtoR = False 
      else                  : LtoR = True #(315 <= ax <= 360) | (0 <= ax <= 45)
  
   def a(p):
      if dom : a = p.lat - b * p.lon 
      else   : a = p.lon - b * p.lat
      return a

   # cl, M and S are not needed in the for stadiumBT calculations but
   #  are nice for debugging.
   
   courseDesc = 'arbitrary'
   distributionTime = time.strftime('%Y-%m-%d_%H:%M:%S_%Z')
   cid = fl + '-' + dc + '-' +  distributionTime
   
   r = {
      'cid'       : cid,
      'courseDesc'       : dc,
      'courseType'       : 'stadium',
      'distributionTime' : distributionTime,
      'length' :  cl,  # course length
      'axis'   :  ax,  # axis (degrees)
      'S'      :  (S.lat, S.lon),  # position of center of start line
      'M'      :  (M.lat, M.lon),  # position of windward mark
      'dom'    :  dom, # domain, function of long (true) or latitude (False)
      'LtoR'   :  LtoR, # True if bounds increase left to right
      'b'      :   b,  # slope constant
      'boundL' :  a(gpsPos.move(S, perp,   w/2 )),            # constant a for left  boundary
      'boundR' :  a(gpsPos.move(S, perp,  -w/2 )),            # constant a for right boundary
      'warnL'  :  a(gpsPos.move(S, perp,  (w/2 - wn/1852) )), # constant a for left  warning
      'warnR'  :  a(gpsPos.move(S, perp, -(w/2 - wn/1852) )), # constant a for right warning
      'centerL':  a(gpsPos.move(S, perp,  cc/(2*1852) )),     # constant a for left  center
      'centerR':  a(gpsPos.move(S, perp, -cc/(2*1852) ))      # constant a for right center
      }

   #check
   if r['dom'] :
      if        not LtoR : 
         if not ( r['boundR']  < r['warnR'] < r['centerR']  <
	          r['centerL'] < r['warnL'] < r['boundL'] ) :
	          raise ValueError("something is messed up in 45 <= ax <= 135.")
      elif       LtoR : 
         if not ( r['boundL']  < r['warnL'] < r['centerL']  <
	          r['centerR'] < r['warnR'] < r['boundR'] ) :
	          raise ValueError("something is messed up in 225 <= ax <= 315.")
      else :  raise ValueError("something is messed up in dom=True.")
   
   if not  r['dom'] :
      if        not LtoR : 
         if not ( r['boundR']  < r['warnR'] < r['centerR']  <
	          r['centerL'] < r['warnL'] < r['boundL'] ) :
	          raise ValueError("something is messed up in 135 <= ax <= 225.")
      elif     LtoR : 
         if not ( r['boundL']  < r['warnL'] < r['centerL']  <
	          r['centerR'] < r['warnR'] < r['boundR'] ) :
	          raise ValueError("something is messed up in (315 <= ax <= 360) | (0 <= ax <= 45).")
      else :  raise ValueError("something is messed up in dom=False.")

   return r

def calcA():
   # calculate race parameters using axis,
   #   RC position as right end of start line, perp to axis and line length to get center 
   #   of start line; axis and  course length, to get mark;
   #   axis, stadium width, and warning width to get boundaries and warning lines;
   #   axis, center of start, and center width to get center indicator lines.

   global  S, M

   readRaceWindow() # re-read current global variables from screen data
   
   perp = (ax - 90 ) % 360 # bearing RC to pin, RC on starboard end of line

   # center of starting line from RC position (right end), perp, and line length
   #  half line length in nm. 1 nm = 1852 m
   S = gpsPos.move(RC, perp, ll / (2 * 1852))

   # windward mark from center of starting line, axis, and course length   
   M = gpsPos.move(S, ax, cl)
   
   writeRaceWindow() # re-write screen with current globals

def calcM():
   # calculate race parameters using RC position and mark M to get course length, aprox axis, then adjust
   #   axis (ax) by a correction angle for S to M rather than RC to M,
   #   assuming RC on starboard end of line. Then calculate as in calcA, excluding M. 

   global  ax, S, cl

   readRaceWindow() # re-read current global variables from screen data
   
   cl = RC.nm(M)  # course length using RC to M.

   correction = math.degrees(math.asin(ll /(2* 1852 * cl)))
   #logging.debug('correction' + str(correction))
   h   = gpsPos.heading(RC, M)

   #now ax is bearing RC to point 1/2 line length right of M, RC on starboard end of line.
   ax  = (h + correction)  % 360 #

   perp = (ax - 90 ) % 360 # bearing RC to pin, RC on starboard end of line

   # center of starting line from RC position (right end), perp, and line length
   #  half line length in nm. 1 nm = 1852 m
   S = gpsPos.move(RC, perp, ll / (2 * 1852))
   
   writeRaceWindow() # re-write screen with current globals


def calcS():
   # calculate race parameters using center of start line and mark M to 
   #  get course length (cl), axis (ax) , and RC position on starboard end of line.

   global  ax, RC, cl

   readRaceWindow() # re-read current global variables from screen data
   
   cl = S.nm(M)  # course length using S to M.

   ax = gpsPos.heading(S, M)

   perp = (ax - 90 ) % 360 # bearing RC to pin, RC on starboard end of line
   
   RC = gpsPos.move(S, perp, ll / (2 * 1852))
   
   writeRaceWindow() # re-write screen with current globals


def defnRaceWindow(w):
   # fields on RC Window main page
   # NB This functionand the next two (writeRaceWindow and readRaceWindow) MUST be
   #    co-ordinated if fiels are changed !!!
   fldLabels = [
 	'fleet', 
 	'decription', 
 	'course type', 
 	'length (nm)', 
 	'axis (degrees)',	
 	'start line length (m)',
 	'stadium width (m)',	 
 	'RC	latitude',
 	'RC	longitude',
 	'start center latitude', 
 	'start center longitude',
 	'mark 1 latitude',	
 	'mark 1 longitude',	
 	'warning width (m)',
 	'center width (m)',
	'Target start time']

   # white=True, grey=False   CONSIDER USING THIS TO GREY CALCULATED VALUES
   # for background shading for calculated fields
   #calculated  = [ True, True, True, True, True, True, True, True, True, False, False, False, False, False, False, False ]
   entries = []
   i = 0
   for f in fldLabels:
      row = tkinter.Frame(w)
      lab = tkinter.Label(row, width=15, text=f, anchor='w')
      #if calculated[i]:
      e = tkinter.Entry(row, bg = "white")
      #else:
      #   e = tkinter.Entry(row, bg = "grey")
      row.pack(side=tkinter.TOP, fill=tkinter.X, padx=5, pady=5)
      lab.pack(side=tkinter.LEFT)
      e.pack(side=tkinter.RIGHT, expand=tkinter.YES, fill=tkinter.X)
      entries.append((e))
      i += 1
   return entries

def writeRaceWindow():
   # re-write screen with current  global variables
   # using global ents for entries
   
   def insert(i, v):
      ents[i].insert(10, str(v))
   
   for i in range (0, len(ents)):
      ents[i].delete(0, tkinter.END)

   i = 0
   for v in (fl, dc, ty, cl, ax, ll, sw, RC.lat, RC.lon, S.lat, S.lon, M.lat, M.lon, wn, cc, tt):
      insert(i,  v)
      i += 1

def readRaceWindow():
   # update globals from screen
   # using global ents for entries
   global  fl, dc, ty, cl, ax, ll, sw, RC, S, M, wn, cc, tt
   fl = str(ents[0].get())
   dc = str(ents[1].get())
   ty = str(ents[2].get())
   cl = float(ents[3].get()) 
   ax = float(ents[4].get()) 
   ll = float(ents[5].get()) 
   sw = float(ents[6].get())
   RC = gpsPos(float(ents[7].get()),  float(ents[8].get()))
   S  = gpsPos(float(ents[9].get()),  float(ents[10].get()))
   M  = gpsPos(float(ents[11].get()), float(ents[12].get()))
   wn = float(ents[13].get()) 
   cc = float(ents[14].get()) 
   tt = float(ents[15].get()) 

def plotWindow(x):
   # note that plot is based on gps and line length. NOT YET. CHANGE USE OF cl
   #      Changing axis or course length  NOT YET. CHANGE USE OF cl without re-calc does not change plot.
   #      This allows manual override of gps point (ie don't re-calc)

   import math

   global  cl, ax, ll, sw, RC, S, M, wn, cc, tt

   x.destroy()

   readRaceWindow() #sync globals from screen

   t = tkinter.Toplevel()
   t.wm_title("Course Plot")

   canvas_width  = 400
   canvas_height = 400
   w = tkinter.Canvas(t,  width=canvas_width, height=canvas_height)
   w.pack()
   w.create_text(canvas_width / 2,     2,            text="N")
   w.create_text(canvas_width / 2, canvas_height-2,  text="S")
   w.create_text(canvas_width,     canvas_height /2, text="E")
   w.create_text(     0,           canvas_height /2, text="W")

   # This cross should be right angles in the center, other than for
   # any difference in the screen horizontal vs vertical per pixael.
   #w.create_line(0, 0, canvas_width, canvas_height, fill="#476042", width=1)
   #w.create_line(0, canvas_height, canvas_width, 0, fill="#476042", width=1)

   #  plot coordinates need to be done in (scaled) nm. Tried to do them in
   #  degrees (gps coordinates) but there is too much skew because a degree
   #  longitude is too much less distance than a degree latitude.

   latScale = 60.0  #  nm per degree lat
   lonScale = 60.0 * math.cos(math.radians(RC.lat)) #   nm per degree long

   #z    = cl /latScale  # course length in degrees (aprox )
   z    = cl   # course length in nm

   scale = 0.4 * canvas_height / z # pix/nm, course length is 0.4 of plot height

   #plot window top left is (0,0), bottom right is (canvas_height, canvas_width)
   # so +ve x is to right (as usual) but +ve y is down (not usual)
   # Use canvas center as start line center, so shift everything in degrees
   #   by start line cemter, that is subtract (xShift, yShift), 
   #  and then to plot shift to canvas center, that is add (x0, y0).
   Shift = S  # degrees lon and lat

   x0 = int(canvas_width  / 2) # pix
   y0 = int(canvas_height / 2) # pix

   # axis (start line center to mark)
   xm = (M.lon - Shift.lon) * lonScale * scale # pix
   ym = (M.lat - Shift.lat) * latScale * scale # pix
   w.create_line(x0, y0, x0 + xm, y0 - ym , fill="#476042", width=1)
  
   #w.create_line(0, 0, 50, 20,      fill="#476042", width=3)

   # start line center (0,0)  to RC
   xm = (RC.lon - Shift.lon) * lonScale * scale # pix
   ym = (RC.lat - Shift.lat) * latScale * scale # pix

   w.create_line(x0, y0, x0 + xm, y0 - ym , fill="#476042", width=3)
   # other half of start line
   w.create_line(x0, y0, x0 - xm, y0 + ym , fill="#476042", width=3)
  
def updateStatus(w, revd):
   
   t = tkinter.Toplevel(w)
   t.wm_title("Update Status")
   logging.debug('revd:')
   logging.debug(str(revd))

   for f in revd :
      row = tkinter.Frame(t)
      lab = tkinter.Label(row, width=30, text=f + ' ' + str(revd[f]), anchor='w')
      row.pack(side=tkinter.TOP, fill=tkinter.X, padx=2, pady=0)
      lab.pack(side=tkinter.LEFT)

   if  BoatList == None : 
      bl = 'boat list not available.'
   else :
      bl = ''
   
   row = tkinter.Frame(t)
   lab = tkinter.Label(row, width=30, text=' Not Updated: ' + bl, anchor='w')
   row.pack(side=tkinter.TOP, fill=tkinter.X, padx=2, pady=2)
   lab.pack(side=tkinter.LEFT)

   if (BoatList != None) : 
      for f in BoatList :
         if f not in  revd :
            row = tkinter.Frame(t)
            lab = tkinter.Label(row, width=30, text='*** ' + f , anchor='w')
            row.pack(side=tkinter.TOP, fill=tkinter.X, padx=2, pady=0)
            lab.pack(side=tkinter.LEFT)


def gpsWindow(w):   
   w.destroy()

   t = tkinter.Toplevel()
   t.wm_title("Other GPS Status    lat    lon")

   # list of tuples (name, host, port)
   # gpsList=(('RC', GPS_HOST, GPS_PORT), ('pin', GPS_HOST, GPS_PORT)) #faking
   for f in gpsList :
      row = tkinter.Frame(t)
      logging.debug('gpsWindow calling  gpsRead with host/port ' + f[1] + f[2])
      pt = gpsRead(f[1], f[2])
      if pt != None : 
         lab = tkinter.Label(row, width=50, text=f[0] + '   ' + 
                     str(pt.lat) + '  '  + str(pt.lon) , anchor='w')
      else :
         lab = tkinter.Label(row, width=30, text=f[0] + '   *****' , anchor='w')
      row.pack(side=tkinter.TOP, fill=tkinter.X, padx=2, pady=0)
      lab.pack(side=tkinter.LEFT)

def extraWindow(w):

   def debugWindow(w):
     w.destroy()

     print('globals')
     for f in (cl, ax, ll, sw, RC, S, M, wn, cc, tt): print(f)
     print()
     print('zoneObj')
     dr.prt()
     print('threads')
     print(str(threading.enumerate()))
     print('dr.distributionRecvd()')
     print(dr.distributionRecvd())
     print('distribution.distRecvd')
     print(distribution.distRecvd)

   t = tkinter.Toplevel()
   t.wm_title("Extra Options")

   bWD  = But(t, text='Save\nRace Parms',    command=(lambda : writeRaceFile(t)))

   bRD  = But(t, text='Load Saved\nRace Parms', command=(lambda : readRaceFile(t)))

   bBL  = But(t, text='Re-read\n BoatList', command=(lambda : readBoatList(t)))

   bGL  = But(t, text='Re-read\n gpsList', command=(lambda : readgpsList(t)))

   bDbg = But(t, text='debugInfo',         command=(lambda : debugWindow(t)))

   bP   = But(t, text='plot',              command=(lambda : plotWindow(t)))

   bG   = But(t, text='other\n GPS',       command=(lambda : gpsWindow(t)))

def But(w, text='x', command='') :
   b = tkinter.Button(w, text=text,  command=command)
   b.pack(side=tkinter.LEFT, padx=5, pady=5)
   return(b)


if __name__ == '__main__':
   logging.info('main thread starting. ' +time.strftime('%Y-%m-%d %H:%M:%S %Z'))
   shutdown = threading.Event()

   dr = distribution.distributer(RC_IP, RC_PORT, shutdown)
   
   dr.start() 
   
   logging.debug(threading.enumerate())

   race = tkinter.Tk()
   race.wm_title("Stadium Race")
   #race.bind('<Return>', (lambda event, e=ents: readRaceWindow(e)))   
   race.bind('<Return>', (lambda event : readRaceWindow()))   

   ents = defnRaceWindow(race)
   writeRaceWindow()

   #calc() # using global ents and other global variables
  
   bGPS   = But(race,  text='get RC GPS',     command=(lambda : getRCgps()))
   
   bCalcA = But(race,  text='calc using\n RC & axis',    command=calcA)
   
   bCalcM = But(race,  text='calc using\n RC & mark',    command=calcM)
   
   bCalcS = But(race,  text='calc using start\n center & mark',
                    command=calcS)
   
   bDist  = But(race,  text='distribute', 
                    command=(lambda :  dr.distribute(makezoneObj())))

   bU     = But(race,  text='update\nStatus',
                    command=(lambda : updateStatus(race, dr.distributionRecvd())))

   bE     = But(race, text='extra',   
                    command=(lambda : extraWindow(race)))

   def abortHandler(signum, frame):
       logging.debug('main thread abortHandler setting shutdown signal.')
       shutdown.set()  # to exit threads
       time.sleep(5)   # wait as long as socket timeout in distributionHandler
       logging.info('main thread exit via abortHandler. ' +time.strftime('%Y-%m-%d %H:%M:%S %Z')+ '\n')
       logging.debug('threads running: ')
       logging.debug(threading.enumerate())
       sys.exit("stadiumRC process killed.")

   # ^C works if process is not deamonized with &
   signal.signal(signal.SIGINT,  abortHandler) # ^C, kill -2
   signal.signal(signal.SIGTERM, abortHandler) # kill -15 (default)

   race.mainloop()

   logging.debug('main thread setting shutdown signal.')
   shutdown.set()  # to exit threads
   time.sleep(5)    # wait as long as socket timeout in distributionHandler
   logging.info('main thread exit via end. ' +time.strftime('%Y-%m-%d %H:%M:%S %Z')+ '\n')
   logging.debug('threads running: ')
   logging.debug(threading.enumerate())
   sys.exit()
