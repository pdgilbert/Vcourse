#!/usr/bin/python3

# License GPL 2. Copyright Paul D. Gilbert, 2017


import socket
import threading
import logging
import json
import time
import tkinter
import gpsd
import math

from gpsPos import gpsPos

logging.basicConfig(level=logging.DEBUG,
                    format='(%(threadName)-9s) %(message)s',)


# Read config variable RC_IP, RC_PORT  from file RCconfig
# in the working directory. 
#    IF THE FILE IS NOT AVAILABLE THE PROGRAM WILL FAIL.
#The file is json and can be generated in python by 
# import json
#  (edit next line example as required)
# config = {'RC_IP' : '192.168.1.1', 'RC_PORT' : 9001, "GPS_HOST": "127.0.0.1",  "GPS_PORT": 2947}
# json.dump(config, open('RCconfig', 'w'))
# The file can also be editted by hand with care to preserve the dict structure.

# read config
config = json.load(open('RCconfig'))   
RC_IP   = config['RC_IP']
RC_PORT = int(config['RC_PORT'])
GPS_HOST = config['GPS_HOST']      # typically "127.0.0.1"
GPS_PORT = int(config['GPS_PORT']) # 2947 is default

# position below means a gpsPos object.
# left and right looking up the course, from race committee (RC) to windward mark (M)
# these global variables should have values as displayed on RaceWindow screen

def writeDefaultRaceParms():
   try : 
      defaultRace = { 'fl':fl, 'dc':dc, 'ty':ty, 'cl':cl, 'ax':ax, 'll':ll, 'sw':sw, 
                      'RC.lat':RC.lat, 'RC.lon':RC.lon, 'S.lat':S.lat, 'S.lon':S.lon, 'M.lat':M.lat, 'M.lon':M.lon,
                      'wn':wn, 'cc':cc, 'tt':tt }
      with open("defaultRace","w") as f:   json.dump(defaultRace, f)
   except :
      print('write failure')

def readDefaultRaceParms():
   global  fl, dc, ty, cl, ax, ll, sw, RC, S, M, wn, cc, tt
   try : 
      with open("defaultRace") as f:  defaultRace = json.load(f)   
      fl   = defaultRace['fl']
      dc   = defaultRace['dc']
      ty   = defaultRace['ty']
      cl   = defaultRace['cl']
      ax   = defaultRace['ax']
      ll   = defaultRace['ll']
      sw   = defaultRace['sw']
      RC   = gpsPos(defaultRace['RC.lat'], defaultRace['RC.lon'])
      S    = gpsPos(defaultRace[ 'S.lat'], defaultRace[ 'S.lon'])
      M    = gpsPos(defaultRace[ 'M.lat'], defaultRace[ 'M.lon'])
      wn   = defaultRace['wn']
      cc   = defaultRace['cc']
      tt   = defaultRace['tt']
   except :
      fl   = 'FX'         # fleet
      dc   = 'race 1'     # description
      ty   = 'stadium'    # course type
      cl   = 1.0          # course length (nm)
      ax   = 240          # course bearing (degrees)
      ll   = 100          # start line length (m)
      sw   = 200          # stadium width (m)
      RC   = gpsPos(44.210171667,-76.51047667) # RC position (default Pen. shoal)
      S    = gpsPos(0,0)  # start line center position
      M    = gpsPos(0,0)  # windward mark position 
      wn   = 20           # distance (m) from boundary at which warning is indicated
      cc   = 20           # width (m) around center axis where center is  indicated 
      tt   = 0            # target start time

readDefaultRaceParms()

raceObjReceived = {}

# start gpsd (-n don't wait for device,  #-S 2947 is default port
#sudo gpsd -n -S 2948 /dev/ttyACM0 

gpsCon = gpsd.connect(host=GPS_HOST, port=GPS_PORT)

def getRCgps():
   # update global RC and write to screen
   global  RC
   RC = gpsPos.getGPS()
   writeRaceWindow()

# initialized as these may be used even before a proper raceObj is generated
raceObj = None
id =None 


def makeRaceObj():
   # This is called by plot?? and distribute to syncronize globals??
   # info to pass to stadiumBT (boat gadget) for calculations.
   # Info for stadiumBT is all in gps positions as that is the best for the
   # boats' calculation of what indicators should go on.
   # The same info is used by plot but is convert to nm in plot.
      
   global raceObj

   # base on current screen values so ensure correct values in globals
   readRaceWindow() 

   # y = a + b * x
   # b = (y_1 - y_2) / (x_1 - x_2)
   # a = y_1 - b * x_1
   
   # 0 or 180 axis would give infinite slope is x is longitude, 
   # so depending on the axis treat domain as longitude (dom=True)
   # or treat domain as latitude (dom=False)
   if        45 <= ax <= 135 : dom = True
   elif     225 <= ax <= 315 : dom = True
   else                       : dom = False

   #  NOT !!
   # Next are globals not on screen but used for raceObj calculation, and plot.
   # These are positions at intersection of the start line extension and one of
   # the lines parallel to axis used for switching indicators (LEDs) on boats.

   w = sw / 1852  # stadium width in nm
   perp = (ax - 90 ) % 360 # bearing RC to pin, RC on starboard end of line.
   #                         This is bearing used for extensions of starting line

   # Two positions on axis (S and M) give slope b.
   if dom : b = (M.lat - S.lat) / (M.lon - S.lon)
   else   : b = (M.lon - S.lon) / (M.lat - S.lat)

   if dom :
      if   45 <= ax <= 135 : LtoR = False
      else                 : LtoR = True  # 225 <= ax <= 315 
   else :
      if   135 <= ax <= 225 : LtoR = False 
      else                  : LtoR = True #(315 <= ax <= 360) | (0 <= ax <= 45)
  
   def a(p):
      if dom : a = p.lat - b * p.lon 
      else   : a = p.lon - b * p.lat
      return a

   # cl, M and S are not needed in the for stadiumBT calculations but
   #  are nice for debugging.
   
   courseDesc = 'arbitrary'
   distributionTime = time.strftime('%Y-%m-%d %H:%M:%S %Z')
   cid = dc + ' ' +  distributionTime
   
   r = {
      'cid'       : cid,
      'courseDesc'       : dc,
      'courseType'       : 'stadium',
      'distributionTime' : distributionTime,
      'length' :  cl,  # course length
      'axis'   :  ax,  # axis (degrees)
      'S'      :  (S.lat, S.lon),  # position of center of start line
      'M'      :  (M.lat, M.lon),  # position of windward mark
      'dom'    :  dom, # domain, function of long (true) or latitude (False)
      'LtoR'   :  LtoR, # True if bounds increase left to right
      'b'      :   b,  # slope constant
      'boundL' :  a(gpsPos.move(S, perp,   w/2 )),            # constant a for left  boundary
      'boundR' :  a(gpsPos.move(S, perp,  -w/2 )),            # constant a for right boundary
      'warnL'  :  a(gpsPos.move(S, perp,  (w/2 - wn/1852) )), # constant a for left  warning
      'warnR'  :  a(gpsPos.move(S, perp, -(w/2 - wn/1852) )), # constant a for right warning
      'centerL':  a(gpsPos.move(S, perp,  cc/(2*1852) )),     # constant a for left  center
      'centerR':  a(gpsPos.move(S, perp, -cc/(2*1852) ))      # constant a for right center
      }

   #check
   if r['dom'] :
      if        not LtoR : 
         if not ( r['boundR']  < r['warnR'] < r['centerR']  <
	          r['centerL'] < r['warnL'] < r['boundL'] ) :
	          raise ValueError("something is messed up in 45 <= ax <= 135.")
      elif       LtoR : 
         if not ( r['boundL']  < r['warnL'] < r['centerL']  <
	          r['centerR'] < r['warnR'] < r['boundR'] ) :
	          raise ValueError("something is messed up in 225 <= ax <= 315.")
      else :  raise ValueError("something is messed up in dom=True.")
   
   if not  r['dom'] :
      if        not LtoR : 
         if not ( r['boundR']  < r['warnR'] < r['centerR']  <
	          r['centerL'] < r['warnL'] < r['boundL'] ) :
	          raise ValueError("something is messed up in 135 <= ax <= 225.")
      elif     LtoR : 
         if not ( r['boundL']  < r['warnL'] < r['centerL']  <
	          r['centerR'] < r['warnR'] < r['boundR'] ) :
	          raise ValueError("something is messed up in (315 <= ax <= 360) | (0 <= ax <= 45).")
      else :  raise ValueError("something is messed up in dom=False.")

   raceObj = r

def calcA():
   # calculate raceObj using axis,
   #   RC position as right end of start line, perp to axis and line length to get center 
   #   of start line; axis and  course length, to get mark;
   #   axis, stadium width, and warning width to get boundaries and warning lines;
   #   axis, center of start, and center width to get center indicator lines.

   global  S, M

   readRaceWindow() # re-read current global variables from screen data
   
   perp = (ax - 90 ) % 360 # bearing RC to pin, RC on starboard end of line

   # center of starting line from RC position (right end), perp, and line length
   #  half line length in nm. 1 nm = 1852 m
   S = gpsPos.move(RC, perp, ll / (2 * 1852))

   # windward mark from center of starting line, axis, and course length   
   M = gpsPos.move(S, ax, cl)
   
   writeRaceWindow() # re-write screen with current globals

def calcM():
   # calculate raceObj using RC position and mark M to get course length, aprox axis, then adjust
   #   axis (ax) by a correction angle for S to M rather than RC to M,
   #   assuming RC on starboard end of line. Then calculate as in calcA, excluding M. 

   global  ax, S, cl

   readRaceWindow() # re-read current global variables from screen data
   
   cl = RC.nm(M)  # course length using RC to M.

   correction = math.degrees(math.asin(ll /(2* 1852 * cl)))
   #logging.debug('correction' + str(correction))
   h   = gpsPos.heading(RC, M)

   #now ax is bearing RC to point 1/2 line length right of M, RC on starboard end of line.
   ax  = (h + correction)  % 360 #

   perp = (ax - 90 ) % 360 # bearing RC to pin, RC on starboard end of line

   # center of starting line from RC position (right end), perp, and line length
   #  half line length in nm. 1 nm = 1852 m
   S = gpsPos.move(RC, perp, ll / (2 * 1852))
   
   writeRaceWindow() # re-write screen with current globals

def distribute():
   # This works by creating a new version of the global object RaceObj, the distributionHandler
   # compares the cid of this with that sent by BT when they connect.
   # There is no "signal" to distributionHandler or BTs. It depends on them checking in.
   
   global raceObjReceived
   
   makeRaceObj()  # this also syncs with screen but does no calc().
   print(json.dumps(raceObj, indent=4))

   # clear dict of boats that have update
   raceObjReceived = {}

   # write raceObj and also global object info to a file, for the record, but distribute is done with raceObj
   with open('distributedCourses/raceObj' + raceObj['cid'] + '.json',"w") as f:
      f.write("\n")
      f.write("raceObj:\n")
      json.dump(raceObj, f, indent=4)
      Race = { 'fl':fl, 'dc':dc, 'ty':ty, 'cl':cl, 'ax':ax, 'll':ll, 'sw':sw, 
               'RC.lat':RC.lat, 'RC.lon':RC.lon, 'S.lat':S.lat, 'S.lon':S.lon, 'M.lat':M.lat, 'M.lon':M.lon,
               'wn':wn, 'cc':cc, 'tt':tt }
      f.write("\n")
      f.write("Race:\n")
      json.dump(Race, f, indent=4)


def defnRaceWindow(w):
   # fields on RC Window main page
   # NB This functionand the next two (writeRaceWindow and readRaceWindow) MUST be
   #    co-ordinated if fiels are changed !!!
   fldLabels = [
 	'fleet', 
 	'decription', 
 	'course type', 
 	'length (nm)', 
 	'axis (degrees)',	
 	'start line length (m)',
 	'stadium width (m)',	 
 	'RC	latitude',
 	'RC	longitude',
 	'start center latitude', 
 	'start center longitude',
 	'mark 1 latitude',	
 	'mark 1 longitude',	
 	'warning width (m)',
 	'center width (m)',
	'Target start time']

   # white=True, grey=False   CONSIDER USING THIS TO GREY CALCULATED VALUES
   # for background shading for calculated fields
   #calculated  = [ True, True, True, True, True, True, True, True, True, False, False, False, False, False, False, False ]
   entries = []
   i = 0
   for f in fldLabels:
      row = tkinter.Frame(w)
      lab = tkinter.Label(row, width=15, text=f, anchor='w')
      #if calculated[i]:
      e = tkinter.Entry(row, bg = "white")
      #else:
      #   e = tkinter.Entry(row, bg = "grey")
      row.pack(side=tkinter.TOP, fill=tkinter.X, padx=5, pady=5)
      lab.pack(side=tkinter.LEFT)
      e.pack(side=tkinter.RIGHT, expand=tkinter.YES, fill=tkinter.X)
      entries.append((e))
      i += 1
   return entries

def writeRaceWindow():
   # re-write screen with current  global variables
   # using global ents for entries
   
   def insert(i, v):
      ents[i].insert(10, str(v))
   
   for i in range (0, len(ents)):
      ents[i].delete(0, tkinter.END)

   i = 0
   for v in (fl, dc, ty, cl, ax, ll, sw, RC.lat, RC.lon, S.lat, S.lon, M.lat, M.lon, wn, cc, tt):
      insert(i,  v)
      i += 1

def readRaceWindow():
   # update globals from screen
   # using global ents for entries
   global  fl, dc, ty, cl, ax, ll, sw, RC, S, M, wn, cc, tt
   fl = str(ents[0].get())
   dc = str(ents[1].get())
   ty = str(ents[2].get())
   cl = float(ents[3].get()) 
   ax = float(ents[4].get()) 
   ll = float(ents[5].get()) 
   sw = float(ents[6].get())
   RC = gpsPos(float(ents[7].get()),  float(ents[8].get()))
   S  = gpsPos(float(ents[9].get()),  float(ents[10].get()))
   M  = gpsPos(float(ents[11].get()), float(ents[12].get()))
   wn = float(ents[13].get()) 
   cc = float(ents[14].get()) 
   tt = float(ents[15].get()) 

def plotWindow(w):
   # note that plot is based on gps and line length. NOT YET. CHANGE USE OF cl
   #      Changing axis or course length  NOT YET. CHANGE USE OF cl without re-calc does not change plot.
   #      This allows manual override of gps point (ie don't re-calc)

   import math

   global  cl, ax, ll, sw, RC, S, M, wn, cc, tt
   readRaceWindow() #sync globals from screen

   t = tkinter.Toplevel(w)
   t.wm_title("Course Plot")

   canvas_width  = 400
   canvas_height = 400
   w = tkinter.Canvas(t,  width=canvas_width, height=canvas_height)
   w.pack()
   w.create_text(canvas_width / 2,     2,            text="N")
   w.create_text(canvas_width / 2, canvas_height-2,  text="S")
   w.create_text(canvas_width,     canvas_height /2, text="E")
   w.create_text(     0,           canvas_height /2, text="W")

   # This cross should be right angles in the center, other than for
   # any difference in the screen horizontal vs vertical per pixael.
   #w.create_line(0, 0, canvas_width, canvas_height, fill="#476042", width=1)
   #w.create_line(0, canvas_height, canvas_width, 0, fill="#476042", width=1)

   #  plot coordinates need to be done in (scaled) nm. Tried to do them in
   #  degrees (gps coordinates) but there is too much skew because a degree
   #  longitude is too much less distance than a degree latitude.

   latScale = 60.0  #  nm per degree lat
   lonScale = 60.0 * math.cos(math.radians(RC.lat)) #   nm per degree long

   #z    = cl /latScale  # course length in degrees (aprox )
   z    = cl   # course length in nm

   scale = 0.4 * canvas_height / z # pix/nm, course length is 0.4 of plot height

   #plot window top left is (0,0), bottom right is (canvas_height, canvas_width)
   # so +ve x is to right (as usual) but +ve y is down (not usual)
   # Use canvas center as start line center, so shift everything in degrees
   #   by start line cemter, that is subtract (xShift, yShift), 
   #  and then to plot shift to canvas center, that is add (x0, y0).
   Shift = S  # degrees lon and lat

   x0 = int(canvas_width  / 2) # pix
   y0 = int(canvas_height / 2) # pix

   # axis (start line center to mark)
   xm = (M.lon - Shift.lon) * lonScale * scale # pix
   ym = (M.lat - Shift.lat) * latScale * scale # pix
   w.create_line(x0, y0, x0 + xm, y0 - ym , fill="#476042", width=1)
  
   #w.create_line(0, 0, 50, 20,      fill="#476042", width=3)

   # start line center (0,0)  to RC
   xm = (RC.lon - Shift.lon) * lonScale * scale # pix
   ym = (RC.lat - Shift.lat) * latScale * scale # pix

   w.create_line(x0, y0, x0 + xm, y0 - ym , fill="#476042", width=3)
   # other half of start line
   w.create_line(x0, y0, x0 - xm, y0 + ym , fill="#476042", width=3)
  
def updateStatus(w):
   import json
   
   t = tkinter.Toplevel(w)
   t.wm_title("Update Status")

   # print(raceObjReceived)
   for f in raceObjReceived :
      row = tkinter.Frame(t)
      lab = tkinter.Label(row, width=15, text=f + ' ' + str(raceObjReceived[f]), anchor='w')
      row.pack(side=tkinter.TOP, fill=tkinter.X, padx=5, pady=5)
      lab.pack(side=tkinter.LEFT)
 

def extraWindow(w):

   def readDefault():
     # no calc
     readDefaultRaceParms()
     writeRaceWindow() #sync screen from globals

   def writeDefault():
     # no calc
     readRaceWindow() #sync globals from screen
     writeDefaultRaceParms()

   def saveRace():
     # no calc, confirm globals are as on screen and DO SOMETHING
     readRaceWindow() #sync globals from screen
     print('DO SOMETHING')

   def debugWindow(w):
     import json
     print('globals')
     for f in (cl, ax, ll, sw, RC, S, M, wn, cc, tt): print(f)
     print()
     print('raceObj')
     print(json.dumps(raceObj, indent=4))

   t = tkinter.Toplevel(w)
   t.wm_title("Extra Options")

   bWD  = But(t, text='Save\nRace Defaults',    command=(lambda : writeDefault()))

   bRD  = But(t, text='Re-read\n Race Defaults', command=(lambda : readDefault()))

   bDbg = But(t, text='debugInfo',        command=(lambda : debugWindow(w)))

   bP   = But(t, text='plot',             command=(lambda : plotWindow(w)))

   #bS   = But(t, text='save race\ndistribution',        command=(lambda : saveRace()))

   #bQ  = But(t, text='Quit!!',           command=(race.quit)) #command=(race.destroy))

def But(w, text='x', command='') :
   b = tkinter.Button(w, text=text,  command=command)
   b.pack(side=tkinter.LEFT, padx=5, pady=5)
   return(b)

class BThandlerThread(threading.Thread):
   # handle a connection from a BT. Check if BT is current and update if not.

   def __init__(self,ip,port,sock):
       threading.Thread.__init__(self)
       self.ip = ip
       self.port = port
       self.sock = sock
       #logging.debug(" New thread started for "+ip+":"+str(port))
   
   def run(self):
       import smp
       import json
       
       global raceObjReceived
 
       #course id that RC has
       if (raceObj == None ) : 
          RCcid = 'none'
       else :
          RCcid = raceObj['cid']
       
       BTcid = smp.rcv(self.sock)  #course id that BT has
       
       #logging.debug(" BTcid " + str(BTcid))
       #logging.debug(" RCcid " + str(RCcid))

       if (raceObj == None ) : 
             smp.snd(self.sock, 'none')
             #logging.debug('sent none.')

       elif (BTcid == RCcid) :
             smp.snd(self.sock, 'ok')
             #logging.debug('sent ok.')
             
       else :
             #logging.debug('sending new raceObj to BT')
             smp.snd(self.sock, json.dumps(raceObj, indent=4))
             #logging.debug('new raceObj sent:')
             r = smp.rcv(self.sock) 
             logging.debug('ADD BT_ID TO LIST. ' + r)
             raceObjReceived[r] = time.strftime('%Y-%m-%d %H:%M:%S %Z')
 

       self.sock.close()
       #logging.debug('closed socket and closing thread.')


def distributionHandler(shutdown):
   # wait for connections from BTs and pass each to a BThandlerThread.
   logging.debug('distributionHandler starting')
   
   global RC_IP, RC_PORT  
   
   tcpsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   tcpsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   tcpsock.bind((RC_IP, RC_PORT))

   while True:
       # often not getting shutdown signal. Seems to work better when a BT has connected. FIX
       if shutdown.wait(0.01): # blocking for interval !! 
          logging.debug('shutting down distributionHandler thread.')
          return() 
       tcpsock.listen(5)  # STALLS HERE LISTENING WITH NO CONNECTIONS, SO NEVER LOOPS  TO shutdown.
       #logging.debug("Waiting for incoming connections on "  + RC_IP + ":" + str(RC_PORT) + " ...")
       (conn, (ip,port)) = tcpsock.accept()
       #logging.debug('Got connection from ' + ip + ':' + str(port))
       BThandlerThread(ip,port,conn).start()

   logging.debug('distributionHandler should not be here.')


if __name__ == '__main__':
   shutdown = threading.Event()

   threading.Thread(name='distributionHandler', 
                   target=distributionHandler,
   		   args=(shutdown,)).start()  # ,) makes single arg a tuple

   race = tkinter.Tk()
   race.wm_title("Stadium Race")
   #race.bind('<Return>', (lambda event, e=ents: readRaceWindow(e)))   
   race.bind('<Return>', (lambda event : readRaceWindow()))   

   ents = defnRaceWindow(race)
   writeRaceWindow()

   #calc() # using global ents and other global variables
  

   bGPS   = But(race, text='get RC GPS',     command=(lambda : getRCgps()))
   
   bCalcA = But(race, text='calc using\n RC & axis',    command=(lambda : calcA()))
   
   bCalcM = But(race, text='calc using\n RC & mark',    command=(lambda : calcM()))
   
   bDist  = But(race, text='distribute',     command=(lambda : distribute()))

   bU     = But(race, text='update\nStatus', command=(lambda : updateStatus(race)))
   #bP     = But(race, text='plot',           command=(lambda : plotWindow(race)))

   bE      = But(race, text='extra',          command=(lambda : extraWindow(race)))

   race.mainloop()

   import time
   import sys
   #  STILL NOT SHUTTING DOWN GRACEFULLY
   #print(sys._current_frames())
    
   shutdown.set()  # to exit threads
   logging.debug('signal shutdown to threads from main.')
   time.sleep(10) # this needs to wait for threats to shutdown, otherwise they have to be killed.
   #                PROBABLY NEED A LOCK
   
   logging.debug('main thread exit.')
   #print(sys._current_frames())
